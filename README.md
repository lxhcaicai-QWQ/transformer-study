# Transformer数列预测模型

本项目使用PyTorch实现了基于Transformer模型的数列预测系统，包含多种模型版本和交互式预测程序，支持MPS（Apple Metal Performance Shaders）加速训练。

## 项目概述

本项目实现了三种不同复杂度的Transformer模型，用于预测数列的下一个数字：
1. **完整版模型**：预测等差数列、等比数列和二次数列
2. **简化版模型**：专注于预测等差数列，模型更小
3. **优化版模型**：支持MPS训练，使用数据归一化和高级优化技术

此外，项目还提供了一个交互式预测程序，允许用户输入自定义数列并获取预测结果。

## 项目结构

```
transformer-study/
├── sequence_predictor.py          # 完整版代码文件（已优化支持MPS）
├── simple_sequence_predictor.py   # 简化版/优化版代码文件
├── interactive_predictor.py      # 交互式数列预测程序
├── complex_interactive_predictor.py  # 复杂数列预测交互程序
├── README.md                      # 项目文档
├── results.png                    # 完整版训练结果可视化图表
├── simple_results.png             # 简化版训练结果可视化图表
├── transformer_sequence_predictor.pth      # 完整版原始模型权重
├── simple_transformer_sequence_predictor.pth  # 简化版模型权重
└── optimized_transformer_sequence_predictor.pth  # 优化版模型权重
```

## 功能特点

- 支持多种数列类型的预测：等差数列、等比数列和二次数列
- 使用Transformer模型捕捉序列中的长距离依赖关系
- 提供训练、验证和测试的准确率评估
- 可视化训练过程中的损失和准确率变化
- 绘制预测值与真实值的对比图
- 支持MPS（Apple Metal Performance Shaders）加速训练
- 数据归一化处理，提高模型收敛速度和稳定性
- 学习率调度和早停机制，防止过拟合
- 梯度裁剪，防止梯度爆炸
- 优化版模型达到100%的测试准确率
- 提供交互式数列预测程序，允许用户输入自定义数列并获取预测结果
- 自动处理不同长度的输入数列，自动填充或截断至模型所需长度
- 支持多种输入格式，灵活解析用户输入的数列
- 提供复杂数列预测交互程序，支持数列类型分析和多步预测
- 自动识别数列类型（等差、等比、二次或复杂数列）
- 支持预测数列的多个后续数字，而不仅仅是下一个数字
- 提供帮助信息，指导用户使用交互程序

## 技术实现

### 数据生成

项目实现了三种类型的数列生成：

1. **等差数列**: $a_n = a_1 + (n-1) \times d$
   - $a_1$: 首项，随机生成
   - $d$: 公差，随机生成

2. **等比数列**: $a_n = a_1 \times r^{(n-1)}$
   - $a_1$: 首项，随机生成
   - $r$: 公比，随机生成

3. **二次数列**: $a_n = a \times n^2 + b \times n + c$
   - $a, b, c$: 系数，随机生成

### 模型架构

Transformer模型包含以下组件：

1. **输入嵌入层**: 将输入序列转换为高维表示
2. **位置编码**: 为序列中的每个位置添加位置信息
3. **Transformer编码器**: 多层自注意力机制和前馈神经网络
4. **输出层**: 将编码器输出转换为预测值

优化版模型使用了以下改进：
- 正弦位置编码而不是学习位置编码
- GELU激活函数代替ReLU
- LayerNorm层提高稳定性
- 更复杂的解码器结构
- Xavier权重初始化

### 训练过程

1. **数据准备**: 生成5000个序列，按7:1.5:1.5的比例划分为训练集、验证集和测试集
2. **数据归一化**: 对每个序列进行归一化处理，提高模型收敛速度
3. **损失函数**: 使用均方误差(MSE)作为损失函数
4. **优化器**: 使用AdamW优化器，添加权重衰减
5. **学习率调度**: 使用ReduceLROnPlateau动态调整学习率
6. **早停机制**: 防止过拟合，节省训练时间
7. **评估指标**: 使用自定义准确率（预测值与真实值的误差在允许范围内视为正确）

## 使用方法

### 环境要求

- Python 3.7+
- PyTorch 1.7+
- NumPy
- Matplotlib
- scikit-learn

### 安装依赖

```bash
pip install torch numpy matplotlib scikit-learn
```

### 运行代码

在虚拟环境中运行以下命令：

**完整版模型**（预测多种数列类型，已优化支持MPS）：
```bash
python sequence_predictor.py
```

**简化版/优化版模型**（仅预测等差数列，准确率更高）：
```bash
python simple_sequence_predictor.py
```

**交互式数列预测程序**（允许用户输入数列并获取预测结果）：
```bash
python interactive_predictor.py
```

**复杂数列预测交互程序**（支持数列类型分析和多步预测）：
```bash
python complex_interactive_predictor.py
```

### 交互式预测程序使用说明

运行交互程序后，按照提示输入数列（用逗号分隔的数字），程序将预测下一个数字：

```
=== 数列预测交互程序 ===
请输入一个数列，程序将预测下一个数字。
输入格式示例：1, 3, 5, 7, 9, 11, 13, 15, 17
输入 'quit' 或 'exit' 退出程序。

模型 'optimized_transformer_sequence_predictor.pth' 加载成功！
请输入数列（用逗号分隔）：1, 3, 5, 7, 9, 11, 13, 15, 17
输入的数列：[1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 13.0, 15.0, 17.0]
预测的下一个数字：18.92
```

## 模型比较

| 特性 | 完整版模型 | 简化版模型 | 优化版模型 |
|------|-----------|-----------|-----------|
| 数列类型 | 等差、等比、二次 | 仅等差数列 | 仅等差数列 |
| 模型复杂度 | 较高 | 较低 | 中等 |
| 训练时间 | 较长 | 较短 | 中等 |
| 测试准确率 | 100% | 100% | 100% |
| 设备支持 | CPU/GPU/MPS | CPU/GPU/MPS | CPU/GPU/MPS |
| 数据归一化 | 有 | 有 | 有 |
| 早停机制 | 有 | 有 | 有 |
| 适用场景 | 复杂数列预测 | 简单数列预测 | 高精度数列预测 |

## 参数设置

代码中的主要超参数可以在文件末尾进行调整：

```python
seq_length = 9      # 输入序列长度
input_dim = 1       # 输入维度
d_model = 128       # 模型维度
nhead = 4           # 多头注意力头数
num_layers = 3      # Transformer层数
batch_size = 32     # 批次大小
learning_rate = 0.001  # 学习率
num_epochs = 100    # 训练轮数
dropout = 0.2      # Dropout比率
```

## 结果展示

运行代码后，将生成以下结果：

1. **控制台输出**:
   - 训练过程中的损失和准确率
   - 最终测试集上的损失和准确率

2. **可视化图表**:
   - 训练和验证的损失曲线
   - 训练和验证的准确率曲线
   - 预测值与真实值的散点图对比

3. **模型文件**:
   - 保存训练好的模型权重

## 示例输出

### 优化版完整模型输出（支持MPS）

```
Using device: mps
Starting training...
Epoch 1/100, Train Loss: 1.1860, Train Acc: 0.1497, Val Loss: 0.4037, Val Acc: 0.3280, LR: 0.001000
Epoch 2/100, Train Loss: 0.3607, Train Acc: 0.2720, Val Loss: 0.0876, Val Acc: 0.4440, LR: 0.001000
...
Epoch 43/100, Train Loss: 0.0404, Train Acc: 0.7500, Val Loss: 0.0056, Val Acc: 1.0000, LR: 0.000125
Early stopping at epoch 43

Testing model...
Test Loss: 0.0055, Test Accuracy: 1.0000

Visualizing results...
Model saved as 'optimized_transformer_sequence_predictor.pth'
```

### 优化版简化模型输出（支持MPS）

```
Using device: mps
Starting training...
Epoch 1/200, Train Loss: 0.0907, Train Acc: 0.1851, Val Loss: 0.0045, Val Acc: 0.0000, LR: 0.001000
Epoch 2/200, Train Loss: 0.0286, Train Acc: 0.2669, Val Loss: 0.0011, Val Acc: 1.0000, LR: 0.001000
...
Epoch 20/200, Train Loss: 0.0124, Train Acc: 0.3989, Val Loss: 0.0003, Val Acc: 1.0000, LR: 0.000250
Early stopping at epoch 20

Testing model...
Test Loss: 0.0003, Test Accuracy: 1.0000

Visualizing results...
Model saved as 'optimized_transformer_sequence_predictor.pth'
```

### 交互式数列预测程序示例

```
=== 数列预测交互程序 ===
请输入一个数列，程序将预测下一个数字。
输入格式示例：1, 3, 5, 7, 9, 11, 13, 15, 17
输入 'quit' 或 'exit' 退出程序。

模型 'optimized_transformer_sequence_predictor.pth' 加载成功！
请输入数列（用逗号分隔）：1, 3, 5, 7, 9, 11, 13, 15, 17
输入的数列：[1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 13.0, 15.0, 17.0]
预测的下一个数字：18.92

请输入数列（用逗号分隔）：2, 4, 6, 8, 10, 12, 14, 16, 18
输入的数列：[2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0]
预测的下一个数字：19.84

请输入数列（用逗号分隔）：quit
感谢使用，再见！
```

### 复杂数列预测交互程序示例

```
=== 复杂数列预测交互程序 ===
本程序使用优化版Transformer模型预测数列的下一个数字。
模型支持等差数列、等比数列、二次数列和复杂数列的预测。
输入格式示例：1, 3, 5, 7, 9, 11, 13, 15, 17
输入 'quit' 或 'exit' 退出程序。
输入 'help' 查看帮助信息。

模型 'optimized_transformer_sequence_predictor.pth' 加载成功！
请输入数列（用逗号分隔）：1, 3, 5, 7, 9, 11, 13, 15, 17
输入的数列：[1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 13.0, 15.0, 17.0]
数列类型分析：等差数列
预测的下一个数字：19.01
是否需要预测多个后续数字？(y/n): y
请输入要预测的数字个数：3
预测的后续3个数字：
  第1个数字：21.01
  第2个数字：23.01
  第3个数字：25.01

请输入数列（用逗号分隔）：1, 4, 9, 16, 25, 36, 49, 64, 81
输入的数列：[1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0, 81.0]
数列类型分析：二次数列
预测的下一个数字：101.89
是否需要预测多个后续数字？(y/n): n

请输入数列（用逗号分隔）：quit
感谢使用，再见！
```

## 扩展建议

1. **增加数列类型**: 可以添加更复杂的数列类型，如斐波那契数列、三角函数数列等
2. **调整模型结构**: 尝试不同的模型维度、层数和注意力头数
3. **超参数优化**: 使用网格搜索或随机搜索优化超参数
4. **增加正则化**: 添加Dropout或权重衰减以防止过拟合
5. **序列长度调整**: 尝试不同长度的输入序列
6. **集成学习**: 结合多个模型的预测结果
7. **自回归预测**: 实现多步预测，而不仅仅是预测下一个数字

## 注意事项

- 确保在运行代码前已安装所有必要的依赖
- 如果有可用的GPU或MPS，代码会自动使用它们进行训练
- 训练时间可能因硬件配置而异，在CPU上可能需要较长时间
- 交互程序需要先运行优化版模型训练生成权重文件
- 模型在训练过程中会自动保存最佳模型权重
